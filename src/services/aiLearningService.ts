// Servi√ßo para sistema de aprendizado da IA
import { supabase } from '../integrations/supabase/client'

export interface AILearning {
  id: string
  keyword: string
  context: string
  user_message: string
  ai_response: string
  category: 'medical' | 'general' | 'evaluation' | 'cannabis' | 'neurology' | 'nephrology'
  confidence_score: number
  usage_count: number
  last_used: string
  created_at: string
  updated_at: string
}

export interface AIKeyword {
  id: string
  keyword: string
  category: string
  importance_score: number
  usage_count: number
  last_used: string
  created_at: string
  updated_at: string
}

export interface AIConversationPattern {
  id: string
  pattern_type: string
  user_input_pattern: string
  best_response: string
  success_rate: number
  usage_count: number
  last_used: string
  created_at: string
  updated_at: string
}

class AILearningService {
  // Salvar aprendizado da IA
  async saveLearning(learningData: Partial<AILearning>) {
    try {
      const { data, error } = await supabase
        .from('ai_learning')
        .insert(learningData)
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Erro ao salvar aprendizado da IA:', error)
      throw error
    }
  }

  // Obter aprendizado por palavra-chave
  async getLearningByKeyword(keyword: string) {
    try {
      const { data, error } = await supabase
        .from('ai_learning')
        .select('*')
        .ilike('keyword', `%${keyword}%`)
        .order('confidence_score', { ascending: false })
        .limit(5)

      if (error) throw error
      return data
    } catch (error) {
      console.error('Erro ao obter aprendizado por palavra-chave:', error)
      throw error
    }
  }

  // Obter aprendizado por categoria
  async getLearningByCategory(category: string) {
    try {
      const { data, error } = await supabase
        .from('ai_learning')
        .select('*')
        .eq('category', category)
        .order('usage_count', { ascending: false })
        .limit(10)

      if (error) throw error
      return data
    } catch (error) {
      console.error('Erro ao obter aprendizado por categoria:', error)
      throw error
    }
  }

  // Obter todas as palavras-chave
  async getKeywords() {
    try {
      const { data, error } = await supabase
        .from('ai_keywords')
        .select('*')
        .order('importance_score', { ascending: false })

      if (error) throw error
      return data
    } catch (error) {
      console.error('Erro ao obter palavras-chave:', error)
      throw error
    }
  }

  // Adicionar nova palavra-chave
  async addKeyword(keyword: string, category: string, importance: number = 0.5) {
    try {
      const { data, error } = await supabase
        .from('ai_keywords')
        .upsert(
          {
            keyword: keyword.toLowerCase(),
            category,
            importance_score: importance,
          },
          {
            onConflict: 'keyword',
          }
        )
        .select()
        .single()

      if (error) throw error
      return data
    } catch (error) {
      console.error('Erro ao adicionar palavra-chave:', error)
      throw error
    }
  }

  // Detectar palavras-chave automaticamente (sem interven√ß√£o manual)
  async detectKeywords(message: string) {
    try {
      // Palavras-chave m√©dicas autom√°ticas
      const medicalKeywords = [
        'dor',
        'dor de cabe√ßa',
        'dor no peito',
        'dor abdominal',
        'cansa√ßo',
        'fadiga',
        'ansiedade',
        'depress√£o',
        'ins√¥nia',
        'convuls√£o',
        'tontura',
        'n√°usea',
        'cannabis',
        'cannabis medicinal',
        'maconha',
        'CBD',
        'THC',
        'neurologia',
        'c√©rebro',
        'nervo',
        'neur√¥nio',
        'epilepsia',
        'nefrologia',
        'rim',
        'renal',
        'di√°lise',
        'transplante',
        'avalia√ß√£o',
        'consulta',
        'exame',
        'sintoma',
        'diagn√≥stico',
        'medicamento',
        'rem√©dio',
        'tratamento',
        'terapia',
      ]

      const detectedKeywords: string[] = []
      const lowerMessage = message.toLowerCase()

      // Detectar palavras-chave automaticamente
      for (const keyword of medicalKeywords) {
        if (lowerMessage.includes(keyword.toLowerCase())) {
          detectedKeywords.push(keyword)
        }
      }

      // Detectar palavras-chave existentes no banco
      const existingKeywords = await this.getKeywords()
      for (const keywordRecord of existingKeywords ?? []) {
        if (keywordRecord?.keyword && lowerMessage.includes(keywordRecord.keyword.toLowerCase())) {
          detectedKeywords.push(keywordRecord.keyword)
        }
      }

      return detectedKeywords
    } catch (error) {
      console.error('Erro ao detectar palavras-chave:', error)
      return []
    }
  }

  // Obter contexto de aprendizado para ChatGPT
  async getLearningContext(message: string) {
    try {
      const keywords = await this.detectKeywords(message)
      let context = ''

      if (keywords.length > 0) {
        context += 'CONTEXTO DE APRENDIZADO:\n'
        for (const keyword of keywords) {
          const learning = await this.getLearningByKeyword(keyword)
          if (learning.length > 0) {
            context += `- ${keyword}: ${learning[0].ai_response || 'Sem resposta'}\n`
          }
        }
      }

      return context
    } catch (error) {
      console.error('Erro ao obter contexto de aprendizado:', error)
      return ''
    }
  }

  // Salvar intera√ß√£o completa (APRENDIZADO AUTOM√ÅTICO)
  async saveInteraction(userMessage: string, aiResponse: string, category: string = 'general') {
    try {
      const keywords = await this.detectKeywords(userMessage)

      // Determinar categoria automaticamente baseada no conte√∫do
      const autoCategory = this.determineCategory(userMessage, keywords)

      // Salvar aprendizado principal
      const learningData = {
        keyword: keywords.length > 0 ? keywords[0] : 'geral',
        context: userMessage,
        user_message: userMessage,
        ai_response: aiResponse,
        category: autoCategory as any,
        confidence_score: this.calculateConfidence(userMessage, keywords),
      }

      await this.saveLearning(learningData)

      // Criar/atualizar palavras-chave automaticamente
      for (const keyword of keywords) {
        await this.autoCreateKeyword(keyword, autoCategory)
      }

      // Criar clusters de aprendizado automaticamente
      await this.createLearningClusters(userMessage, aiResponse, autoCategory)

      console.log('üß† IA aprendeu automaticamente:', {
        keywords: keywords.length,
        category: autoCategory,
        confidence: learningData.confidence_score,
      })
    } catch (error) {
      console.error('Erro ao salvar intera√ß√£o:', error)
    }
  }

  // Determinar categoria automaticamente
  private determineCategory(message: string, keywords: string[]): string {
    const lowerMessage = message.toLowerCase()

    // Cannabis
    if (
      lowerMessage.includes('cannabis') ||
      lowerMessage.includes('maconha') ||
      lowerMessage.includes('cbd') ||
      lowerMessage.includes('thc')
    ) {
      return 'cannabis'
    }

    // Neurologia
    if (
      lowerMessage.includes('c√©rebro') ||
      lowerMessage.includes('nervo') ||
      lowerMessage.includes('convuls√£o') ||
      lowerMessage.includes('epilepsia') ||
      lowerMessage.includes('neurologia')
    ) {
      return 'neurology'
    }

    // Nefrologia
    if (
      lowerMessage.includes('rim') ||
      lowerMessage.includes('renal') ||
      lowerMessage.includes('di√°lise') ||
      lowerMessage.includes('transplante') ||
      lowerMessage.includes('nefrologia')
    ) {
      return 'nephrology'
    }

    // Avalia√ß√£o
    if (
      lowerMessage.includes('avalia√ß√£o') ||
      lowerMessage.includes('consulta') ||
      lowerMessage.includes('exame') ||
      lowerMessage.includes('sintoma')
    ) {
      return 'evaluation'
    }

    // M√©dico geral
    if (
      lowerMessage.includes('dor') ||
      lowerMessage.includes('cansa√ßo') ||
      lowerMessage.includes('ansiedade') ||
      lowerMessage.includes('depress√£o') ||
      lowerMessage.includes('medicamento') ||
      lowerMessage.includes('tratamento')
    ) {
      return 'medical'
    }

    return 'general'
  }

  // Calcular confian√ßa automaticamente
  private calculateConfidence(message: string, keywords: string[]): number {
    let confidence = 0.5 // Base

    // Mais palavras-chave = maior confian√ßa
    confidence += keywords.length * 0.1

    // Mensagens mais longas = maior confian√ßa
    if (message.length > 50) confidence += 0.1
    if (message.length > 100) confidence += 0.1

    // Palavras m√©dicas espec√≠ficas = maior confian√ßa
    const medicalWords = ['sintoma', 'diagn√≥stico', 'tratamento', 'medicamento', 'consulta']
    const medicalCount = medicalWords.filter(word => message.toLowerCase().includes(word)).length
    confidence += medicalCount * 0.05

    return Math.min(confidence, 1.0) // M√°ximo 1.0
  }

  // Criar palavra-chave automaticamente
  private async autoCreateKeyword(keyword: string, category: string) {
    try {
      const { data, error } = await supabase
        .from('ai_keywords')
        .upsert(
          {
            keyword: keyword.toLowerCase(),
            category,
            importance_score: this.calculateImportance(keyword, category),
            usage_count: 1,
            last_used: new Date().toISOString(),
          },
          {
            onConflict: 'keyword',
          }
        )
        .select()
        .single()

      if (error && !error.message.includes('duplicate')) {
        console.error('Erro ao criar palavra-chave:', error)
      }
    } catch (error) {
      console.error('Erro ao criar palavra-chave automaticamente:', error)
    }
  }

  // Calcular import√¢ncia da palavra-chave
  private calculateImportance(keyword: string, category: string): number {
    let importance = 0.5

    // Palavras-chave m√©dicas importantes
    const importantWords = ['cannabis', 'convuls√£o', 'dor', 'ansiedade', 'depress√£o']
    if (importantWords.includes(keyword.toLowerCase())) {
      importance = 0.9
    }

    // Categorias importantes
    if (category === 'cannabis' || category === 'neurology') {
      importance = Math.max(importance, 0.8)
    }

    return importance
  }

  // Criar clusters de aprendizado automaticamente
  private async createLearningClusters(userMessage: string, aiResponse: string, category: string) {
    try {
      // Analisar padr√µes na conversa
      const patterns = this.analyzeConversationPatterns(userMessage, aiResponse)

      for (const pattern of patterns) {
        // Verificar se o padr√£o j√° existe
        const { data: existingPattern } = await supabase
          .from('ai_conversation_patterns')
          .select('id, usage_count')
          .eq('user_input_pattern', pattern.userPattern)
          .single()

        if (existingPattern) {
          // Atualizar contador de uso
          await supabase
            .from('ai_conversation_patterns')
            .update({
              usage_count: existingPattern.usage_count + 1,
              last_used: new Date().toISOString(),
            })
            .eq('id', existingPattern.id)
        } else {
          // Criar novo padr√£o
          await supabase.from('ai_conversation_patterns').insert({
            pattern_type: pattern.type,
            user_input_pattern: pattern.userPattern,
            best_response: pattern.bestResponse,
            success_rate: pattern.successRate,
            usage_count: 1,
            last_used: new Date().toISOString(),
          })
        }
      }
    } catch (error) {
      console.error('Erro ao criar clusters de aprendizado:', error)
    }
  }

  // Analisar padr√µes de conversa
  private analyzeConversationPatterns(userMessage: string, aiResponse: string) {
    const patterns = []

    // Padr√£o de sauda√ß√£o
    if (userMessage.toLowerCase().includes('ol√°') || userMessage.toLowerCase().includes('oi')) {
      patterns.push({
        type: 'greeting',
        userPattern: 'sauda√ß√£o',
        bestResponse: aiResponse,
        successRate: 0.8,
      })
    }

    // Padr√£o de pergunta m√©dica
    if (
      userMessage.includes('?') &&
      (userMessage.includes('dor') || userMessage.includes('sintoma'))
    ) {
      patterns.push({
        type: 'medical_question',
        userPattern: 'pergunta m√©dica',
        bestResponse: aiResponse,
        successRate: 0.9,
      })
    }

    // Padr√£o de agradecimento
    if (
      userMessage.toLowerCase().includes('obrigado') ||
      userMessage.toLowerCase().includes('valeu')
    ) {
      patterns.push({
        type: 'thanks',
        userPattern: 'agradecimento',
        bestResponse: aiResponse,
        successRate: 0.7,
      })
    }

    return patterns
  }

  // Obter estat√≠sticas de aprendizado
  async getLearningStats() {
    try {
      const { data: learningStats, error: learningError } = await supabase
        .from('ai_learning')
        .select('category, confidence_score, usage_count')

      const { data: keywordStats, error: keywordError } = await supabase
        .from('ai_keywords')
        .select('category, importance_score, usage_count')

      if (learningError) throw learningError
      if (keywordError) throw keywordError

      return {
        totalInteractions: learningStats?.length || 0,
        totalKeywords: keywordStats?.length || 0,
        categories: {
          medical: learningStats?.filter(s => s.category === 'medical').length || 0,
          cannabis: learningStats?.filter(s => s.category === 'cannabis').length || 0,
          neurology: learningStats?.filter(s => s.category === 'neurology').length || 0,
          nephrology: learningStats?.filter(s => s.category === 'nephrology').length || 0,
          evaluation: learningStats?.filter(s => s.category === 'evaluation').length || 0,
          general: learningStats?.filter(s => s.category === 'general').length || 0,
        },
        avgConfidence:
          learningStats?.reduce((acc, s) => acc + s.confidence_score, 0) /
          (learningStats?.length || 1),
        totalUsage: learningStats?.reduce((acc, s) => acc + s.usage_count, 0) || 0,
      }
    } catch (error) {
      console.error('Erro ao obter estat√≠sticas de aprendizado:', error)
      return null
    }
  }
}

export const aiLearningService = new AILearningService()
