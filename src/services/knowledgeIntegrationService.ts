// üß† SERVI√áO DE INTEGRA√á√ÉO DE CONHECIMENTO
// Integra automaticamente conhecimento extra√≠do das conversas com a IA N√¥a Esperanza

import { gptBuilderService } from './gptBuilderService'
import { aiLearningService } from './aiLearningService'
import { supabase } from '../integrations/supabase/client'

export interface KnowledgeNode {
  id: string
  concept: string
  relatedConcepts: string[]
  confidence: number
  source: 'conversation' | 'document' | 'clinical' | 'protocol'
  metadata: {
    extractedFrom: string
    timestamp: Date
    keywords: string[]
    context: string
  }
}

export interface KnowledgeConnection {
  from: string
  to: string
  relationship: 'similar' | 'related' | 'contradicts' | 'supports' | 'depends_on'
  strength: number
  context: string
}

export class KnowledgeIntegrationService {
  // üîó CRIAR CONEX√ïES ENTRE CONHECIMENTOS

  async createKnowledgeConnections(newKnowledge: any): Promise<void> {
    try {
      const existingKnowledge = await this.getAllKnowledgeNodes()

      for (const existing of existingKnowledge) {
        const connectionStrength = this.calculateConnectionStrength(newKnowledge, existing)

        if (connectionStrength > 0.6) {
          await this.saveKnowledgeConnection(newKnowledge, existing, connectionStrength)
        }
      }
    } catch (error) {
      console.error('Erro ao criar conex√µes de conhecimento:', error)
    }
  }

  private calculateConnectionStrength(newKnowledge: any, existing: any): number {
    const newKeywords = newKnowledge.extractedConcepts || []
    const existingKeywords = existing.keywords || []

    // Calcular sobreposi√ß√£o de palavras-chave
    const intersection = newKeywords.filter((keyword: string) =>
      existingKeywords.includes(keyword)
    ).length

    const union = new Set([...newKeywords, ...existingKeywords]).size

    return intersection / union
  }

  private async saveKnowledgeConnection(from: any, to: any, strength: number): Promise<void> {
    try {
      await supabase.from('knowledge_connections').insert({
        from_concept: from.concept || from.title,
        to_concept: to.concept || to.title,
        relationship: strength > 0.8 ? 'similar' : 'related',
        strength,
        context: `Conectado automaticamente em ${new Date().toISOString()}`,
        created_at: new Date().toISOString(),
      })
    } catch (error) {
      console.error('Erro ao salvar conex√£o de conhecimento:', error)
    }
  }

  // üß† INTEGRAR COM SISTEMA DE APRENDIZADOS

  async integrateWithAILearning(document: any): Promise<void> {
    try {
      const learningEntries = this.extractLearningEntries(document)

      for (const entry of learningEntries) {
        await aiLearningService.saveLearning({
          keyword: entry.keyword,
          context: entry.context,
          user_message: entry.userMessage,
          ai_response: entry.aiResponse,
          category: entry.category,
          confidence_score: entry.confidence,
        })
      }
    } catch (error) {
      console.error('Erro ao integrar com AI Learning:', error)
    }
  }

  private extractLearningEntries(document: any): any[] {
    const content = document.content
    const keywords = this.extractKeywords(content)

    return keywords.map((keyword, index) => ({
      keyword: keyword.toLowerCase(),
      context: document.category || 'conversational-extraction',
      user_message: `Informa√ß√£o sobre ${keyword}`,
      ai_response: this.generateAIResponse(content, keyword),
      category: document.category || 'knowledge',
      confidence: 0.9,
    }))
  }

  private extractKeywords(content: string): string[] {
    const medicalTerms = [
      'CBD',
      'THC',
      'cannabis',
      'epilepsia',
      'convuls√£o',
      'dor neurop√°tica',
      'protocolo',
      'dosagem',
      'tratamento',
      'medica√ß√£o',
      'sintoma',
      'diagn√≥stico',
      'avalia√ß√£o',
      'anamnese',
      'neurologia',
      'nefrologia',
    ]

    const foundTerms = medicalTerms.filter(term =>
      content.toLowerCase().includes(term.toLowerCase())
    )

    return foundTerms.length > 0 ? foundTerms : ['conhecimento m√©dico']
  }

  private generateAIResponse(content: string, keyword: string): string {
    const relevantSection =
      content.split('\n').find(line => line.toLowerCase().includes(keyword.toLowerCase())) ||
      content.substring(0, 200)

    return `Baseado na discuss√£o com Dr. Ricardo Valen√ßa: ${relevantSection}`
  }

  // üìä OBTER TODOS OS N√ìS DE CONHECIMENTO

  private async getAllKnowledgeNodes(): Promise<KnowledgeNode[]> {
    try {
      const { data: documents } = await supabase
        .from('documentos_mestres')
        .select('*')
        .eq('is_active', true)

      return (documents || []).map(doc => ({
        id: doc.id,
        concept: doc.title,
        relatedConcepts: this.extractKeywords(doc.content),
        confidence: 0.9,
        source: 'document' as const,
        metadata: {
          extractedFrom: 'documentos_mestres',
          timestamp: new Date(doc.updated_at),
          keywords: this.extractKeywords(doc.content),
          context: doc.category || 'general',
        },
      }))
    } catch (error) {
      console.error('Erro ao obter n√≥s de conhecimento:', error)
      return []
    }
  }

  // üîç BUSCAR CONHECIMENTO CONTEXTUAL

  async findContextualKnowledge(query: string): Promise<any[]> {
    try {
      const { data: connections } = await supabase
        .from('knowledge_connections')
        .select(
          `
          *,
          from_concept,
          to_concept,
          relationship,
          strength
        `
        )
        .or(`from_concept.ilike.%${query}%,to_concept.ilike.%${query}%`)
        .order('strength', { ascending: false })
        .limit(5)

      return connections || []
    } catch (error) {
      console.error('Erro ao buscar conhecimento contextual:', error)
      return []
    }
  }

  // üéØ GERAR RESPOSTA CONTEXTUALIZADA

  async generateContextualResponse(userMessage: string): Promise<string> {
    try {
      const contextualKnowledge = await this.findContextualKnowledge(userMessage)
      const relevantDocs = await gptBuilderService.searchDocuments(userMessage)

      let context = ''

      if (contextualKnowledge.length > 0) {
        context += 'Conhecimento relacionado encontrado:\n'
        contextualKnowledge.forEach(conn => {
          context += `‚Ä¢ ${conn.from_concept} ‚Üí ${conn.to_concept} (${conn.relationship})\n`
        })
      }

      if (relevantDocs.length > 0) {
        context += '\nDocumentos relevantes:\n'
        relevantDocs.slice(0, 3).forEach(doc => {
          context += `‚Ä¢ ${doc.title}: ${doc.content.substring(0, 100)}...\n`
        })
      }

      return context || 'Nenhum contexto espec√≠fico encontrado na base de conhecimento.'
    } catch (error) {
      console.error('Erro ao gerar resposta contextualizada:', error)
      return 'Erro ao buscar contexto na base de conhecimento.'
    }
  }

  // üìà ESTAT√çSTICAS DE INTEGRA√á√ÉO

  async getIntegrationStats(): Promise<{
    totalDocuments: number
    totalConnections: number
    knowledgeNodes: number
    integrationHealth: number
  }> {
    try {
      const [documents, connections, learningEntries] = await Promise.all([
        gptBuilderService.getDocuments(),
        supabase.from('knowledge_connections').select('id'),
        supabase.from('ai_learning').select('id'),
      ])

      const totalDocuments = documents.length
      const totalConnections = connections.data?.length || 0
      const knowledgeNodes = totalDocuments
      const integrationHealth =
        totalConnections > 0 ? Math.min(100, (totalConnections / totalDocuments) * 100) : 0

      return {
        totalDocuments,
        totalConnections,
        knowledgeNodes,
        integrationHealth,
      }
    } catch (error) {
      console.error('Erro ao obter estat√≠sticas de integra√ß√£o:', error)
      return {
        totalDocuments: 0,
        totalConnections: 0,
        knowledgeNodes: 0,
        integrationHealth: 0,
      }
    }
  }

  // üîÑ SINCRONIZA√á√ÉO COMPLETA

  async performFullIntegration(): Promise<void> {
    try {
      console.log('üîÑ Iniciando integra√ß√£o completa de conhecimento...')

      const documents = await gptBuilderService.getDocuments()

      for (const document of documents) {
        // Integrar com AI Learning
        await this.integrateWithAILearning(document)

        // Criar conex√µes de conhecimento
        await this.createKnowledgeConnections(document)
      }

      console.log('‚úÖ Integra√ß√£o completa finalizada!')
    } catch (error) {
      console.error('Erro na integra√ß√£o completa:', error)
      throw error
    }
  }
}

// Inst√¢ncia global do servi√ßo
export const knowledgeIntegrationService = new KnowledgeIntegrationService()
